//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AuthClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    register(body: RegisterRequest | undefined): Observable<AuthenticationResponseResponse> {
        let url_ = this.baseUrl + "/auth/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthenticationResponseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthenticationResponseResponse>;
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<AuthenticationResponseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthenticationResponseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    login(body: LoginRequest | undefined): Observable<AuthenticationResponseResponse> {
        let url_ = this.baseUrl + "/auth/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthenticationResponseResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthenticationResponseResponse>;
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<AuthenticationResponseResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthenticationResponseResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ChairTypesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param name (optional) 
     * @param color (optional) 
     * @param colorText (optional) 
     * @param language (optional) 
     * @param chairImage (optional) 
     * @return Success
     */
    createOne(name: string | undefined, color: string | undefined, colorText: string | undefined, language: Language | undefined, chairImage: FileParameter | undefined): Observable<BooleanResponse> {
        let url_ = this.baseUrl + "/chair-types/create-one";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (name === null || name === undefined)
            throw new Error("The parameter 'name' cannot be null.");
        else
            content_.append("Name", name.toString());
        if (color === null || color === undefined)
            throw new Error("The parameter 'color' cannot be null.");
        else
            content_.append("Color", color.toString());
        if (colorText === null || colorText === undefined)
            throw new Error("The parameter 'colorText' cannot be null.");
        else
            content_.append("ColorText", colorText.toString());
        if (language === null || language === undefined)
            throw new Error("The parameter 'language' cannot be null.");
        else
            content_.append("Language", language.toString());
        if (chairImage === null || chairImage === undefined)
            throw new Error("The parameter 'chairImage' cannot be null.");
        else
            content_.append("ChairImage", chairImage.data, chairImage.fileName ? chairImage.fileName : "ChairImage");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOne(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOne(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanResponse>;
        }));
    }

    protected processCreateOne(response: HttpResponseBase): Observable<BooleanResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getAll(body: PagintationRequest | undefined): Observable<GetChairTypeDtoPagedResultResponse> {
        let url_ = this.baseUrl + "/chair-types/get-all";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetChairTypeDtoPagedResultResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetChairTypeDtoPagedResultResponse>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<GetChairTypeDtoPagedResultResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetChairTypeDtoPagedResultResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class EventPlaceClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param name (optional) 
     * @param language (optional) 
     * @param seatingChart (optional) 
     * @param seatingChartImage (optional) 
     * @param columns (optional) 
     * @param rows (optional) 
     * @return Success
     */
    createOne(name: string | undefined, language: Language | undefined, seatingChart: SeatingChart | undefined, seatingChartImage: FileParameter | undefined, columns: number | undefined, rows: number | undefined): Observable<BooleanResponse> {
        let url_ = this.baseUrl + "/event-place/create-one";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (name === null || name === undefined)
            throw new Error("The parameter 'name' cannot be null.");
        else
            content_.append("Name", name.toString());
        if (language === null || language === undefined)
            throw new Error("The parameter 'language' cannot be null.");
        else
            content_.append("Language", language.toString());
        if (seatingChart === null || seatingChart === undefined)
            throw new Error("The parameter 'seatingChart' cannot be null.");
        else
            content_.append("SeatingChart", seatingChart.toString());
        if (seatingChartImage === null || seatingChartImage === undefined)
            throw new Error("The parameter 'seatingChartImage' cannot be null.");
        else
            content_.append("SeatingChartImage", seatingChartImage.data, seatingChartImage.fileName ? seatingChartImage.fileName : "SeatingChartImage");
        if (columns === null || columns === undefined)
            throw new Error("The parameter 'columns' cannot be null.");
        else
            content_.append("Columns", columns.toString());
        if (rows === null || rows === undefined)
            throw new Error("The parameter 'rows' cannot be null.");
        else
            content_.append("Rows", rows.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOne(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOne(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanResponse>;
        }));
    }

    protected processCreateOne(response: HttpResponseBase): Observable<BooleanResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAll(): Observable<EventPlaceDtoListResponse> {
        let url_ = this.baseUrl + "/event-place/get-all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EventPlaceDtoListResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EventPlaceDtoListResponse>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<EventPlaceDtoListResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EventPlaceDtoListResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class EventsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOne(body: CreateEventDto | undefined): Observable<BooleanResponse> {
        let url_ = this.baseUrl + "/events/create-one";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOne(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOne(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanResponse>;
        }));
    }

    protected processCreateOne(response: HttpResponseBase): Observable<BooleanResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getAll(body: PagintationRequest | undefined): Observable<GetEventsDtoPagedResultResponse> {
        let url_ = this.baseUrl + "/events/get-all";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetEventsDtoPagedResultResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetEventsDtoPagedResultResponse>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<GetEventsDtoPagedResultResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetEventsDtoPagedResultResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class FirstTitleClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOne(body: CreateFirstTitleDto | undefined): Observable<BooleanResponse> {
        let url_ = this.baseUrl + "/first-title/create-one";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOne(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOne(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanResponse>;
        }));
    }

    protected processCreateOne(response: HttpResponseBase): Observable<BooleanResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param page (optional) 
     * @param size (optional) 
     * @return Success
     */
    getAll(page: number | undefined, size: number | undefined): Observable<GetTitleFirstDtoPagedResultResponse> {
        let url_ = this.baseUrl + "/first-title/get-all?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (size === null)
            throw new Error("The parameter 'size' cannot be null.");
        else if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetTitleFirstDtoPagedResultResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetTitleFirstDtoPagedResultResponse>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<GetTitleFirstDtoPagedResultResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetTitleFirstDtoPagedResultResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getOne(id: number | undefined): Observable<TitleFirstDtoResponse> {
        let url_ = this.baseUrl + "/first-title/get-one?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOne(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOne(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TitleFirstDtoResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TitleFirstDtoResponse>;
        }));
    }

    protected processGetOne(response: HttpResponseBase): Observable<TitleFirstDtoResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TitleFirstDtoResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    editOne(body: UpdateTitleDto | undefined): Observable<BooleanResponse> {
        let url_ = this.baseUrl + "/first-title/edit-one";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditOne(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditOne(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanResponse>;
        }));
    }

    protected processEditOne(response: HttpResponseBase): Observable<BooleanResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteOne(id: number | undefined): Observable<BooleanResponse> {
        let url_ = this.baseUrl + "/first-title/delete-one?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOne(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOne(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanResponse>;
        }));
    }

    protected processDeleteOne(response: HttpResponseBase): Observable<BooleanResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PersonTypeClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOne(body: CreatePersonTypeDto | undefined): Observable<BooleanResponse> {
        let url_ = this.baseUrl + "/person-type/create-one";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOne(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOne(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanResponse>;
        }));
    }

    protected processCreateOne(response: HttpResponseBase): Observable<BooleanResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getAll(body: PagintationRequest | undefined): Observable<GetPersonTypeDtoPagedResultResponse> {
        let url_ = this.baseUrl + "/person-type/get-all";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetPersonTypeDtoPagedResultResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetPersonTypeDtoPagedResultResponse>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<GetPersonTypeDtoPagedResultResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetPersonTypeDtoPagedResultResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getOne(id: number | undefined): Observable<PersonTypeDtoResponse> {
        let url_ = this.baseUrl + "/person-type/get-one?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOne(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOne(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PersonTypeDtoResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PersonTypeDtoResponse>;
        }));
    }

    protected processGetOne(response: HttpResponseBase): Observable<PersonTypeDtoResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PersonTypeDtoResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    editOne(body: UpdatePersonTypeDto | undefined): Observable<BooleanResponse> {
        let url_ = this.baseUrl + "/person-type/edit-one";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditOne(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditOne(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanResponse>;
        }));
    }

    protected processEditOne(response: HttpResponseBase): Observable<BooleanResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteOne(id: number | undefined): Observable<BooleanResponse> {
        let url_ = this.baseUrl + "/person-type/delete-one?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOne(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOne(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanResponse>;
        }));
    }

    protected processDeleteOne(response: HttpResponseBase): Observable<BooleanResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SecondTitleClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOne(body: CreateSecondTitleDto | undefined): Observable<BooleanResponse> {
        let url_ = this.baseUrl + "/second-title/create-one";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOne(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOne(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanResponse>;
        }));
    }

    protected processCreateOne(response: HttpResponseBase): Observable<BooleanResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getAll(body: PagintationRequest | undefined): Observable<GetTitleSecondDtoPagedResultResponse> {
        let url_ = this.baseUrl + "/second-title/get-all";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetTitleSecondDtoPagedResultResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetTitleSecondDtoPagedResultResponse>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<GetTitleSecondDtoPagedResultResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetTitleSecondDtoPagedResultResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getOne(id: number | undefined): Observable<TitleSecondDtoResponse> {
        let url_ = this.baseUrl + "/second-title/get-one?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOne(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOne(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TitleSecondDtoResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TitleSecondDtoResponse>;
        }));
    }

    protected processGetOne(response: HttpResponseBase): Observable<TitleSecondDtoResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TitleSecondDtoResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    editOne(body: UpdateTitleSecondDto | undefined): Observable<BooleanResponse> {
        let url_ = this.baseUrl + "/second-title/edit-one";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditOne(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditOne(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanResponse>;
        }));
    }

    protected processEditOne(response: HttpResponseBase): Observable<BooleanResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteOne(id: number | undefined): Observable<BooleanResponse> {
        let url_ = this.baseUrl + "/second-title/delete-one?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOne(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOne(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanResponse>;
        }));
    }

    protected processDeleteOne(response: HttpResponseBase): Observable<BooleanResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BooleanResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class AuthenticationResponse implements IAuthenticationResponse {
    id?: string | undefined;
    username?: string | undefined;
    email?: string | undefined;
    token?: string | undefined;

    constructor(data?: IAuthenticationResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.username = _data["username"];
            this.email = _data["email"];
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): AuthenticationResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticationResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["username"] = this.username;
        data["email"] = this.email;
        data["token"] = this.token;
        return data;
    }
}

export interface IAuthenticationResponse {
    id?: string | undefined;
    username?: string | undefined;
    email?: string | undefined;
    token?: string | undefined;
}

export class AuthenticationResponseResponse implements IAuthenticationResponseResponse {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: AuthenticationResponse;
    byteData?: string | undefined;

    constructor(data?: IAuthenticationResponseResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.succeeded = _data["succeeded"];
            this.message = _data["message"];
            this.statusCode = _data["statusCode"];
            this.data = _data["data"] ? AuthenticationResponse.fromJS(_data["data"]) : <any>undefined;
            this.byteData = _data["byteData"];
        }
    }

    static fromJS(data: any): AuthenticationResponseResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticationResponseResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeeded"] = this.succeeded;
        data["message"] = this.message;
        data["statusCode"] = this.statusCode;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["byteData"] = this.byteData;
        return data;
    }
}

export interface IAuthenticationResponseResponse {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: AuthenticationResponse;
    byteData?: string | undefined;
}

export class BooleanResponse implements IBooleanResponse {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: boolean;
    byteData?: string | undefined;

    constructor(data?: IBooleanResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.succeeded = _data["succeeded"];
            this.message = _data["message"];
            this.statusCode = _data["statusCode"];
            this.data = _data["data"];
            this.byteData = _data["byteData"];
        }
    }

    static fromJS(data: any): BooleanResponse {
        data = typeof data === 'object' ? data : {};
        let result = new BooleanResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeeded"] = this.succeeded;
        data["message"] = this.message;
        data["statusCode"] = this.statusCode;
        data["data"] = this.data;
        data["byteData"] = this.byteData;
        return data;
    }
}

export interface IBooleanResponse {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: boolean;
    byteData?: string | undefined;
}

export class CreateEventDto implements ICreateEventDto {
    name?: string | undefined;
    language?: Language;

    constructor(data?: ICreateEventDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.language = _data["language"];
        }
    }

    static fromJS(data: any): CreateEventDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateEventDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["language"] = this.language;
        return data;
    }
}

export interface ICreateEventDto {
    name?: string | undefined;
    language?: Language;
}

export class CreateFirstTitleDto implements ICreateFirstTitleDto {
    name?: string | undefined;
    language?: Language;

    constructor(data?: ICreateFirstTitleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.language = _data["language"];
        }
    }

    static fromJS(data: any): CreateFirstTitleDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFirstTitleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["language"] = this.language;
        return data;
    }
}

export interface ICreateFirstTitleDto {
    name?: string | undefined;
    language?: Language;
}

export class CreatePersonTypeDto implements ICreatePersonTypeDto {
    name?: string | undefined;
    language?: Language;
    color?: string | undefined;

    constructor(data?: ICreatePersonTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.language = _data["language"];
            this.color = _data["color"];
        }
    }

    static fromJS(data: any): CreatePersonTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePersonTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["language"] = this.language;
        data["color"] = this.color;
        return data;
    }
}

export interface ICreatePersonTypeDto {
    name?: string | undefined;
    language?: Language;
    color?: string | undefined;
}

export class CreateSecondTitleDto implements ICreateSecondTitleDto {
    name?: string | undefined;
    language?: Language;

    constructor(data?: ICreateSecondTitleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.language = _data["language"];
        }
    }

    static fromJS(data: any): CreateSecondTitleDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSecondTitleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["language"] = this.language;
        return data;
    }
}

export interface ICreateSecondTitleDto {
    name?: string | undefined;
    language?: Language;
}

export class EventPlaceDto implements IEventPlaceDto {
    id?: number;
    name?: string | undefined;
    language?: Language;
    seatingChart?: SeatingChart;
    seatingChartImagePath?: string | undefined;
    columns?: number | undefined;
    rows?: number | undefined;

    constructor(data?: IEventPlaceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.language = _data["language"];
            this.seatingChart = _data["seatingChart"];
            this.seatingChartImagePath = _data["seatingChartImagePath"];
            this.columns = _data["columns"];
            this.rows = _data["rows"];
        }
    }

    static fromJS(data: any): EventPlaceDto {
        data = typeof data === 'object' ? data : {};
        let result = new EventPlaceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["language"] = this.language;
        data["seatingChart"] = this.seatingChart;
        data["seatingChartImagePath"] = this.seatingChartImagePath;
        data["columns"] = this.columns;
        data["rows"] = this.rows;
        return data;
    }
}

export interface IEventPlaceDto {
    id?: number;
    name?: string | undefined;
    language?: Language;
    seatingChart?: SeatingChart;
    seatingChartImagePath?: string | undefined;
    columns?: number | undefined;
    rows?: number | undefined;
}

export class EventPlaceDtoListResponse implements IEventPlaceDtoListResponse {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: EventPlaceDto[] | undefined;
    byteData?: string | undefined;

    constructor(data?: IEventPlaceDtoListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.succeeded = _data["succeeded"];
            this.message = _data["message"];
            this.statusCode = _data["statusCode"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(EventPlaceDto.fromJS(item));
            }
            this.byteData = _data["byteData"];
        }
    }

    static fromJS(data: any): EventPlaceDtoListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new EventPlaceDtoListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeeded"] = this.succeeded;
        data["message"] = this.message;
        data["statusCode"] = this.statusCode;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["byteData"] = this.byteData;
        return data;
    }
}

export interface IEventPlaceDtoListResponse {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: EventPlaceDto[] | undefined;
    byteData?: string | undefined;
}

export class GetChairTypeDto implements IGetChairTypeDto {
    id?: number;
    name?: string | undefined;
    language?: Language;
    color?: string | undefined;
    colorText?: string | undefined;
    imagePath?: string | undefined;

    constructor(data?: IGetChairTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.language = _data["language"];
            this.color = _data["color"];
            this.colorText = _data["colorText"];
            this.imagePath = _data["imagePath"];
        }
    }

    static fromJS(data: any): GetChairTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetChairTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["language"] = this.language;
        data["color"] = this.color;
        data["colorText"] = this.colorText;
        data["imagePath"] = this.imagePath;
        return data;
    }
}

export interface IGetChairTypeDto {
    id?: number;
    name?: string | undefined;
    language?: Language;
    color?: string | undefined;
    colorText?: string | undefined;
    imagePath?: string | undefined;
}

export class GetChairTypeDtoPagedResult implements IGetChairTypeDtoPagedResult {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: GetChairTypeDto[] | undefined;
    currentPage?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    messages?: string[] | undefined;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;

    constructor(data?: IGetChairTypeDtoPagedResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.succeeded = _data["succeeded"];
            this.message = _data["message"];
            this.statusCode = _data["statusCode"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(GetChairTypeDto.fromJS(item));
            }
            this.currentPage = _data["currentPage"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(item);
            }
            (<any>this).hasPreviousPage = _data["hasPreviousPage"];
            (<any>this).hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): GetChairTypeDtoPagedResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetChairTypeDtoPagedResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeeded"] = this.succeeded;
        data["message"] = this.message;
        data["statusCode"] = this.statusCode;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["currentPage"] = this.currentPage;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item);
        }
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IGetChairTypeDtoPagedResult {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: GetChairTypeDto[] | undefined;
    currentPage?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    messages?: string[] | undefined;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class GetChairTypeDtoPagedResultResponse implements IGetChairTypeDtoPagedResultResponse {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: GetChairTypeDtoPagedResult;
    byteData?: string | undefined;

    constructor(data?: IGetChairTypeDtoPagedResultResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.succeeded = _data["succeeded"];
            this.message = _data["message"];
            this.statusCode = _data["statusCode"];
            this.data = _data["data"] ? GetChairTypeDtoPagedResult.fromJS(_data["data"]) : <any>undefined;
            this.byteData = _data["byteData"];
        }
    }

    static fromJS(data: any): GetChairTypeDtoPagedResultResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetChairTypeDtoPagedResultResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeeded"] = this.succeeded;
        data["message"] = this.message;
        data["statusCode"] = this.statusCode;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["byteData"] = this.byteData;
        return data;
    }
}

export interface IGetChairTypeDtoPagedResultResponse {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: GetChairTypeDtoPagedResult;
    byteData?: string | undefined;
}

export class GetEventsDto implements IGetEventsDto {
    id?: number;
    name?: string | undefined;
    language?: Language;

    constructor(data?: IGetEventsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.language = _data["language"];
        }
    }

    static fromJS(data: any): GetEventsDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetEventsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["language"] = this.language;
        return data;
    }
}

export interface IGetEventsDto {
    id?: number;
    name?: string | undefined;
    language?: Language;
}

export class GetEventsDtoPagedResult implements IGetEventsDtoPagedResult {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: GetEventsDto[] | undefined;
    currentPage?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    messages?: string[] | undefined;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;

    constructor(data?: IGetEventsDtoPagedResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.succeeded = _data["succeeded"];
            this.message = _data["message"];
            this.statusCode = _data["statusCode"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(GetEventsDto.fromJS(item));
            }
            this.currentPage = _data["currentPage"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(item);
            }
            (<any>this).hasPreviousPage = _data["hasPreviousPage"];
            (<any>this).hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): GetEventsDtoPagedResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetEventsDtoPagedResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeeded"] = this.succeeded;
        data["message"] = this.message;
        data["statusCode"] = this.statusCode;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["currentPage"] = this.currentPage;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item);
        }
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IGetEventsDtoPagedResult {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: GetEventsDto[] | undefined;
    currentPage?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    messages?: string[] | undefined;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class GetEventsDtoPagedResultResponse implements IGetEventsDtoPagedResultResponse {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: GetEventsDtoPagedResult;
    byteData?: string | undefined;

    constructor(data?: IGetEventsDtoPagedResultResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.succeeded = _data["succeeded"];
            this.message = _data["message"];
            this.statusCode = _data["statusCode"];
            this.data = _data["data"] ? GetEventsDtoPagedResult.fromJS(_data["data"]) : <any>undefined;
            this.byteData = _data["byteData"];
        }
    }

    static fromJS(data: any): GetEventsDtoPagedResultResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetEventsDtoPagedResultResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeeded"] = this.succeeded;
        data["message"] = this.message;
        data["statusCode"] = this.statusCode;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["byteData"] = this.byteData;
        return data;
    }
}

export interface IGetEventsDtoPagedResultResponse {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: GetEventsDtoPagedResult;
    byteData?: string | undefined;
}

export class GetPersonTypeDto implements IGetPersonTypeDto {
    id?: number;
    name?: string | undefined;
    language?: Language;
    color?: string | undefined;

    constructor(data?: IGetPersonTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.language = _data["language"];
            this.color = _data["color"];
        }
    }

    static fromJS(data: any): GetPersonTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetPersonTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["language"] = this.language;
        data["color"] = this.color;
        return data;
    }
}

export interface IGetPersonTypeDto {
    id?: number;
    name?: string | undefined;
    language?: Language;
    color?: string | undefined;
}

export class GetPersonTypeDtoPagedResult implements IGetPersonTypeDtoPagedResult {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: GetPersonTypeDto[] | undefined;
    currentPage?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    messages?: string[] | undefined;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;

    constructor(data?: IGetPersonTypeDtoPagedResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.succeeded = _data["succeeded"];
            this.message = _data["message"];
            this.statusCode = _data["statusCode"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(GetPersonTypeDto.fromJS(item));
            }
            this.currentPage = _data["currentPage"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(item);
            }
            (<any>this).hasPreviousPage = _data["hasPreviousPage"];
            (<any>this).hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): GetPersonTypeDtoPagedResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetPersonTypeDtoPagedResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeeded"] = this.succeeded;
        data["message"] = this.message;
        data["statusCode"] = this.statusCode;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["currentPage"] = this.currentPage;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item);
        }
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IGetPersonTypeDtoPagedResult {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: GetPersonTypeDto[] | undefined;
    currentPage?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    messages?: string[] | undefined;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class GetPersonTypeDtoPagedResultResponse implements IGetPersonTypeDtoPagedResultResponse {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: GetPersonTypeDtoPagedResult;
    byteData?: string | undefined;

    constructor(data?: IGetPersonTypeDtoPagedResultResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.succeeded = _data["succeeded"];
            this.message = _data["message"];
            this.statusCode = _data["statusCode"];
            this.data = _data["data"] ? GetPersonTypeDtoPagedResult.fromJS(_data["data"]) : <any>undefined;
            this.byteData = _data["byteData"];
        }
    }

    static fromJS(data: any): GetPersonTypeDtoPagedResultResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetPersonTypeDtoPagedResultResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeeded"] = this.succeeded;
        data["message"] = this.message;
        data["statusCode"] = this.statusCode;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["byteData"] = this.byteData;
        return data;
    }
}

export interface IGetPersonTypeDtoPagedResultResponse {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: GetPersonTypeDtoPagedResult;
    byteData?: string | undefined;
}

export class GetTitleFirstDto implements IGetTitleFirstDto {
    id?: number;
    name?: string | undefined;
    language?: Language;
    color?: string | undefined;
    colorText?: string | undefined;
    imagePath?: string | undefined;

    constructor(data?: IGetTitleFirstDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.language = _data["language"];
            this.color = _data["color"];
            this.colorText = _data["colorText"];
            this.imagePath = _data["imagePath"];
        }
    }

    static fromJS(data: any): GetTitleFirstDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetTitleFirstDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["language"] = this.language;
        data["color"] = this.color;
        data["colorText"] = this.colorText;
        data["imagePath"] = this.imagePath;
        return data;
    }
}

export interface IGetTitleFirstDto {
    id?: number;
    name?: string | undefined;
    language?: Language;
    color?: string | undefined;
    colorText?: string | undefined;
    imagePath?: string | undefined;
}

export class GetTitleFirstDtoPagedResult implements IGetTitleFirstDtoPagedResult {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: GetTitleFirstDto[] | undefined;
    currentPage?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    messages?: string[] | undefined;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;

    constructor(data?: IGetTitleFirstDtoPagedResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.succeeded = _data["succeeded"];
            this.message = _data["message"];
            this.statusCode = _data["statusCode"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(GetTitleFirstDto.fromJS(item));
            }
            this.currentPage = _data["currentPage"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(item);
            }
            (<any>this).hasPreviousPage = _data["hasPreviousPage"];
            (<any>this).hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): GetTitleFirstDtoPagedResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetTitleFirstDtoPagedResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeeded"] = this.succeeded;
        data["message"] = this.message;
        data["statusCode"] = this.statusCode;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["currentPage"] = this.currentPage;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item);
        }
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IGetTitleFirstDtoPagedResult {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: GetTitleFirstDto[] | undefined;
    currentPage?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    messages?: string[] | undefined;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class GetTitleFirstDtoPagedResultResponse implements IGetTitleFirstDtoPagedResultResponse {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: GetTitleFirstDtoPagedResult;
    byteData?: string | undefined;

    constructor(data?: IGetTitleFirstDtoPagedResultResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.succeeded = _data["succeeded"];
            this.message = _data["message"];
            this.statusCode = _data["statusCode"];
            this.data = _data["data"] ? GetTitleFirstDtoPagedResult.fromJS(_data["data"]) : <any>undefined;
            this.byteData = _data["byteData"];
        }
    }

    static fromJS(data: any): GetTitleFirstDtoPagedResultResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetTitleFirstDtoPagedResultResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeeded"] = this.succeeded;
        data["message"] = this.message;
        data["statusCode"] = this.statusCode;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["byteData"] = this.byteData;
        return data;
    }
}

export interface IGetTitleFirstDtoPagedResultResponse {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: GetTitleFirstDtoPagedResult;
    byteData?: string | undefined;
}

export class GetTitleSecondDto implements IGetTitleSecondDto {
    id?: number;
    name?: string | undefined;
    language?: Language;
    color?: string | undefined;
    colorText?: string | undefined;
    imagePath?: string | undefined;

    constructor(data?: IGetTitleSecondDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.language = _data["language"];
            this.color = _data["color"];
            this.colorText = _data["colorText"];
            this.imagePath = _data["imagePath"];
        }
    }

    static fromJS(data: any): GetTitleSecondDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetTitleSecondDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["language"] = this.language;
        data["color"] = this.color;
        data["colorText"] = this.colorText;
        data["imagePath"] = this.imagePath;
        return data;
    }
}

export interface IGetTitleSecondDto {
    id?: number;
    name?: string | undefined;
    language?: Language;
    color?: string | undefined;
    colorText?: string | undefined;
    imagePath?: string | undefined;
}

export class GetTitleSecondDtoPagedResult implements IGetTitleSecondDtoPagedResult {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: GetTitleSecondDto[] | undefined;
    currentPage?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    messages?: string[] | undefined;
    readonly hasPreviousPage?: boolean;
    readonly hasNextPage?: boolean;

    constructor(data?: IGetTitleSecondDtoPagedResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.succeeded = _data["succeeded"];
            this.message = _data["message"];
            this.statusCode = _data["statusCode"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(GetTitleSecondDto.fromJS(item));
            }
            this.currentPage = _data["currentPage"];
            this.totalPages = _data["totalPages"];
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
            if (Array.isArray(_data["messages"])) {
                this.messages = [] as any;
                for (let item of _data["messages"])
                    this.messages!.push(item);
            }
            (<any>this).hasPreviousPage = _data["hasPreviousPage"];
            (<any>this).hasNextPage = _data["hasNextPage"];
        }
    }

    static fromJS(data: any): GetTitleSecondDtoPagedResult {
        data = typeof data === 'object' ? data : {};
        let result = new GetTitleSecondDtoPagedResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeeded"] = this.succeeded;
        data["message"] = this.message;
        data["statusCode"] = this.statusCode;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["currentPage"] = this.currentPage;
        data["totalPages"] = this.totalPages;
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item);
        }
        data["hasPreviousPage"] = this.hasPreviousPage;
        data["hasNextPage"] = this.hasNextPage;
        return data;
    }
}

export interface IGetTitleSecondDtoPagedResult {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: GetTitleSecondDto[] | undefined;
    currentPage?: number;
    totalPages?: number;
    totalCount?: number;
    pageSize?: number;
    messages?: string[] | undefined;
    hasPreviousPage?: boolean;
    hasNextPage?: boolean;
}

export class GetTitleSecondDtoPagedResultResponse implements IGetTitleSecondDtoPagedResultResponse {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: GetTitleSecondDtoPagedResult;
    byteData?: string | undefined;

    constructor(data?: IGetTitleSecondDtoPagedResultResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.succeeded = _data["succeeded"];
            this.message = _data["message"];
            this.statusCode = _data["statusCode"];
            this.data = _data["data"] ? GetTitleSecondDtoPagedResult.fromJS(_data["data"]) : <any>undefined;
            this.byteData = _data["byteData"];
        }
    }

    static fromJS(data: any): GetTitleSecondDtoPagedResultResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetTitleSecondDtoPagedResultResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeeded"] = this.succeeded;
        data["message"] = this.message;
        data["statusCode"] = this.statusCode;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["byteData"] = this.byteData;
        return data;
    }
}

export interface IGetTitleSecondDtoPagedResultResponse {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: GetTitleSecondDtoPagedResult;
    byteData?: string | undefined;
}

export enum Language {
    Arabic = 1,
    English = 2,
}

export class LoginRequest implements ILoginRequest {
    email?: string | undefined;
    password?: string | undefined;

    constructor(data?: ILoginRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): LoginRequest {
        data = typeof data === 'object' ? data : {};
        let result = new LoginRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        return data;
    }
}

export interface ILoginRequest {
    email?: string | undefined;
    password?: string | undefined;
}

export class PagintationRequest implements IPagintationRequest {
    pageSize?: number;
    pageNumber?: number;

    constructor(data?: IPagintationRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageSize = _data["pageSize"];
            this.pageNumber = _data["pageNumber"];
        }
    }

    static fromJS(data: any): PagintationRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PagintationRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageSize"] = this.pageSize;
        data["pageNumber"] = this.pageNumber;
        return data;
    }
}

export interface IPagintationRequest {
    pageSize?: number;
    pageNumber?: number;
}

export class PersonTypeDto implements IPersonTypeDto {
    id?: number;
    name?: string | undefined;
    language?: Language;
    color?: string | undefined;

    constructor(data?: IPersonTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.language = _data["language"];
            this.color = _data["color"];
        }
    }

    static fromJS(data: any): PersonTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new PersonTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["language"] = this.language;
        data["color"] = this.color;
        return data;
    }
}

export interface IPersonTypeDto {
    id?: number;
    name?: string | undefined;
    language?: Language;
    color?: string | undefined;
}

export class PersonTypeDtoResponse implements IPersonTypeDtoResponse {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: PersonTypeDto;
    byteData?: string | undefined;

    constructor(data?: IPersonTypeDtoResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.succeeded = _data["succeeded"];
            this.message = _data["message"];
            this.statusCode = _data["statusCode"];
            this.data = _data["data"] ? PersonTypeDto.fromJS(_data["data"]) : <any>undefined;
            this.byteData = _data["byteData"];
        }
    }

    static fromJS(data: any): PersonTypeDtoResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PersonTypeDtoResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeeded"] = this.succeeded;
        data["message"] = this.message;
        data["statusCode"] = this.statusCode;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["byteData"] = this.byteData;
        return data;
    }
}

export interface IPersonTypeDtoResponse {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: PersonTypeDto;
    byteData?: string | undefined;
}

export class RegisterRequest implements IRegisterRequest {
    firstName?: string | undefined;
    lastName?: string | undefined;
    email?: string | undefined;
    password?: string | undefined;

    constructor(data?: IRegisterRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): RegisterRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["password"] = this.password;
        return data;
    }
}

export interface IRegisterRequest {
    firstName?: string | undefined;
    lastName?: string | undefined;
    email?: string | undefined;
    password?: string | undefined;
}

export enum SeatingChart {
    ColsRows = 1,
    Circular = 2,
}

export class TitleFirstDto implements ITitleFirstDto {
    id?: number;
    name?: string | undefined;
    language?: Language;

    constructor(data?: ITitleFirstDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.language = _data["language"];
        }
    }

    static fromJS(data: any): TitleFirstDto {
        data = typeof data === 'object' ? data : {};
        let result = new TitleFirstDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["language"] = this.language;
        return data;
    }
}

export interface ITitleFirstDto {
    id?: number;
    name?: string | undefined;
    language?: Language;
}

export class TitleFirstDtoResponse implements ITitleFirstDtoResponse {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: TitleFirstDto;
    byteData?: string | undefined;

    constructor(data?: ITitleFirstDtoResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.succeeded = _data["succeeded"];
            this.message = _data["message"];
            this.statusCode = _data["statusCode"];
            this.data = _data["data"] ? TitleFirstDto.fromJS(_data["data"]) : <any>undefined;
            this.byteData = _data["byteData"];
        }
    }

    static fromJS(data: any): TitleFirstDtoResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TitleFirstDtoResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeeded"] = this.succeeded;
        data["message"] = this.message;
        data["statusCode"] = this.statusCode;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["byteData"] = this.byteData;
        return data;
    }
}

export interface ITitleFirstDtoResponse {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: TitleFirstDto;
    byteData?: string | undefined;
}

export class TitleSecondDto implements ITitleSecondDto {
    id?: number;
    name?: string | undefined;
    language?: Language;

    constructor(data?: ITitleSecondDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.language = _data["language"];
        }
    }

    static fromJS(data: any): TitleSecondDto {
        data = typeof data === 'object' ? data : {};
        let result = new TitleSecondDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["language"] = this.language;
        return data;
    }
}

export interface ITitleSecondDto {
    id?: number;
    name?: string | undefined;
    language?: Language;
}

export class TitleSecondDtoResponse implements ITitleSecondDtoResponse {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: TitleSecondDto;
    byteData?: string | undefined;

    constructor(data?: ITitleSecondDtoResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.succeeded = _data["succeeded"];
            this.message = _data["message"];
            this.statusCode = _data["statusCode"];
            this.data = _data["data"] ? TitleSecondDto.fromJS(_data["data"]) : <any>undefined;
            this.byteData = _data["byteData"];
        }
    }

    static fromJS(data: any): TitleSecondDtoResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TitleSecondDtoResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeeded"] = this.succeeded;
        data["message"] = this.message;
        data["statusCode"] = this.statusCode;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["byteData"] = this.byteData;
        return data;
    }
}

export interface ITitleSecondDtoResponse {
    succeeded?: boolean;
    message?: string | undefined;
    statusCode?: number;
    data?: TitleSecondDto;
    byteData?: string | undefined;
}

export class UpdatePersonTypeDto implements IUpdatePersonTypeDto {
    id?: number;
    name?: string | undefined;
    language?: Language;
    color?: string | undefined;

    constructor(data?: IUpdatePersonTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.language = _data["language"];
            this.color = _data["color"];
        }
    }

    static fromJS(data: any): UpdatePersonTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePersonTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["language"] = this.language;
        data["color"] = this.color;
        return data;
    }
}

export interface IUpdatePersonTypeDto {
    id?: number;
    name?: string | undefined;
    language?: Language;
    color?: string | undefined;
}

export class UpdateTitleDto implements IUpdateTitleDto {
    id?: number;
    name?: string | undefined;
    language?: Language;

    constructor(data?: IUpdateTitleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.language = _data["language"];
        }
    }

    static fromJS(data: any): UpdateTitleDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTitleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["language"] = this.language;
        return data;
    }
}

export interface IUpdateTitleDto {
    id?: number;
    name?: string | undefined;
    language?: Language;
}

export class UpdateTitleSecondDto implements IUpdateTitleSecondDto {
    id?: number;
    name?: string | undefined;
    language?: Language;

    constructor(data?: IUpdateTitleSecondDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.language = _data["language"];
        }
    }

    static fromJS(data: any): UpdateTitleSecondDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTitleSecondDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["language"] = this.language;
        return data;
    }
}

export interface IUpdateTitleSecondDto {
    id?: number;
    name?: string | undefined;
    language?: Language;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}